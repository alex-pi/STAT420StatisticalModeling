#(1:30) ^ 2
set.seed(42)
y  = 5 * x0 + x1 + rnorm(n = 30, mean = 0 , sd = 1)
mean(y)
X <- cbind(x0, x1)
X
typeof(X)
matrix(X)
X <- matrix(x0, x1)
X
X <- cbind(x0, x1)
X
X[17, ]
X[17, ] + X[19, ]
sum(X[17, ] + X[19, ])
X[17,19, ]
sum(X[17, ] + X[19, ])
sum(X[17, ], X[19, ])
library(MASS)
x0 <- rep(1, 30)
x1 <- (1:30) ^ 2
set.seed(42)
y  = 5 * x0 + x1 + rnorm(n = 30, mean = 0 , sd = 1)
solve(t(X) %*% X) %*% t(X) %*% y
beta_hat <- solve(t(X) %*% X) %*% t(X) %*% y
beta_hat
sum(beta_hat)
y_hat <- X %*% beta_hat
y_hat
sum((y - y_hat)^2)
pnorm(6, mean = 0, sd = 4)
pnorm(-4, mean = 0, sd = 4)
pnorm(-4, mean = 0, sd = 4)
pnorm(6, mean = 10, sd = 4)
pnorm(6, mean = 0, sd = 4)
pnorm(9, mean = 15, sd = 4)
pnorm(11 mean = 15, sd = 4)
pnorm(11, mean = 15, sd = 4)
pnorm(3 , mean = 5, sd = 4)
pnorm(3 , mean = 5, sd = 4, lower.tail = FALSE)
pnorm(-2, mena = 0, sd = 4, lower.tail = FALSE)
pnorm(-2, mean = 0, sd = 4, lower.tail = FALSE)
pnorm(3 , mean = y, sd = 4, lower.tail = FALSE)
pnorm(-2, mean = 0, sd = 4, lower.tail = FALSE)
y = 5
pnorm(3 , mean = y, sd = 4, lower.tail = FALSE)
pnorm(-2, mean = 0, sd = 4, lower.tail = FALSE)
ft <- faithful
?ft
?faithful
ftm <- lm(ft$eruptions ~ ft$waiting)
ftm$coefficients
ftm
ftm$coefficients
summary(ftm$coefficients)
summary(ftm)
ftm$coefficients
ftm$coefficients[1]
ftm$coefficients
ftm <- lm(eruptions ~ waiting, data = ft)
# Note that these give a different rounding,
# does it matter which one we get for the test?
ftm$coefficients
ftm$coefficients[1]
1-pnorm(3, sd = 4)
ftm$coef
ftm$coef[2]
predict(ftm, newdata = data.frame(
waiting = 80
))
predict(ftm, newdata = data.frame(
waiting = 120
))
p1 <- predict(ftm, newdata = data.frame(
waiting = 80
))
p2 <- predict(ftm, newdata = data.frame(
waiting = 120
))
p1 < min(ft$eruptions) | p1 > max(ft$eruptions)
p2 < min(ft$eruptions) | p2 > max(ft$eruptions)
p1 < min(ft$eruptions) | p1 > max(ft$eruptions)
p2 < min(ft$eruptions) | p2 > max(ft$eruptions)
p1 < min(ft$eruptions) | p1 > max(ft$eruptions)
p2 < min(ft$eruptions) | p2 > max(ft$eruptions)
summary(ftm)
nrow(ft)
summary(ftm)$sigma
sum((ft$eruptions - ftm$fitted.values) ^ 2)
# Question 10
summary(ftm)$r.squared
(sst <- sum((ft$eruptions - mean(ft$eruptions) ^ 2))
(sst <- sum((ft$eruptions - mean(ft$eruptions) ^ 2)
aa
(sst <- sum((ft$eruptions - mean(ft$eruptions)) ^ 2))
var(ft$eruptions)
sst / (n-1)
sst / (nrow(ft)-1)
sd(ft$eruptions)
sd(ft$eruptions)
sqrt(sst / (nrow(ft)-1))
(ssreg <- sum((ftm$fitted.values - mean(ft$eruptions)) ^ 2))
ssreg / sst
# Question 10
summary(ftm)$r.squared
ssreg + sse
# RSS or Residual standard error
sse <- sum((ft$eruptions - ftm$fitted.values) ^ 2)
ssreg + sse
sst
# Question 10
summary(ftm)$r.squared
sd(ft$eruptions - ftm$fitted.values)
sd(ft$eruptions - ftm$fitted.values)
sqrt(sum((ft$eruptions - ftm$fitted.values) ^ 2) / (nrow(ft)-2))
sd(ft$eruptions - ftm$fitted.values)
sqrt(sum((ft$eruptions - ftm$fitted.values) ^ 2) / (nrow(ft)-1))
ft <- faithful
ftm <- lm(ft$eruptions ~ ft$waiting)
x <- ft$waiting
x_mean <- mean(ft$waiting)
Sxx <- sum((x - x_mean)^2)
y <- ft$eruptions
y_mean <- mean(ft$eruptions)
Syy <- sum((x - x_mean)*(y - y_mean))
Sxy <- sum((x - x_mean)*(y - y_mean))
beta_1_hat <- Sxy / Sxx
(beta_1_hat <- Sxy / Sxx)
ftm$coef
(beta_0_hat <- y_mean - (beta_1_hat * x_mean))
# RSS or Residual standard error
sse <- sum((ft$eruptions - ftm$fitted.values) ^ 2)
summary(ftm)
summary(ftm)$sigma
# RSS or Residual standard error
sse <- sum((ft$eruptions - ftm$fitted.values) ^ 2)
sse
names(summary(ftm))
summary(ftm)$sigma
summary(ftm)
sse / (nrow(ft) - )
sse / (nrow(ft) - 2)
sqrt(sse / (nrow(ft) - 2))
summary(ftm)
summary(ftm)$sigma
sqrt(sse / (nrow(ft) - 2))
ssreg / sst
summary(ftm)$sigma
ssreg / sst
summary(ftm)$r.square
ssreg / sst
# Note that these give a different rounding,
# does it matter which one we get for the test?
ftm$coefficients
ftm$coef[2]
?pt
pt(2.1, df = 5)
pt(2.1, df = 5, lower.tail = FALSE)
2 * pt(2.1, df = 5, lower.tail = FALSE)
#
qt(0.995, df = 10 - 8)
pt(9.924843, df = 10 - 8, lower.tail = FALSE)
pt(9.924843, df = 10 - 8)
1 - (2 * pt(9.924843, df = 10 - 8, lower.tail = FALSE))
qt(0.005, df = 10 - 8)
qt(0.005, df = 10 - 8, lower.tail = FALSE)
abs(qt(0.005, df = 10 - 8))
#
qt(0.995, df = 10 - 8)
qt(0.005, df = 10 - 8, lower.tail = FALSE)
abs(qt(0.005, df = 10 - 8))
1 - (2 * pt(-9.924843, df = 10 - 8, lower.tail = FALSE))
1 - (2 * pt(9.924843, df = 10 - 8, lower.tail = FALSE))
# We want the remaining 0.01 split evenly left and right.
# we can move the cl to 0.99 + 0.005 to get the
# positive value from the right
qt(0.95, df = 10 - 8)
# Or we can do it from the left 1 - 0.995 and make sure
# we change the resulting crit value to positive.
qt(0.05, df = 10 - 8, lower.tail = FALSE)
abs(qt(0.05, df = 10 - 8))
# We want the remaining 0.01 split evenly left and right.
# we can move the cl to 0.99 + 0.005 to get the
# positive value from the right
qt(0.95, df = 10 - 2)
# Or we can do it from the left 1 - 0.995 and make sure
# we change the resulting crit value to positive.
qt(0.05, df = 10 - 2, lower.tail = FALSE)
abs(qt(0.05, df = 10 - 2))
# Go back to the confidence level used
1 - (2 * pt(1.859548, df = 10 - 2, lower.tail = FALSE))
Sxx <- 1.5
s_2 <- 4
beta_1_hat_var <- s_2 / Sxx
beta_1_hat_var
beta_1_hat_sd <- sqrt(s_2 / Sxx)
beta_1_hat_sd
?pm
?pn
1 - pnorm(4.2, mean = 4, sd = beta_1_hat_sd)
1 - pnorm(4.2, mean = 4, sd = beta_1_hat_sd)
?faithful
ft < - faithful
ft <- faithful
head(ft)
ftm <- lm(ft$eruptions ~ ft$waiting)
summary(ftm)
summary(ftm)$sigma
n <- nrow(ft)
n
sum((ft$eruptions - ftm$fitted.values)^2) / (n - 1)
sqrt(sum((ft$eruptions - ftm$fitted.values)^2) / (n - 1))
sqrt(sum((ft$eruptions - ftm$fitted.values)^2) / (n - 2))
Sxx <- sum((ft$waiting - mean(ft$waiting)) ^ 2)
summary(ftm)$sigma / sqrt(Sxx)
summary(ftm)
summary(ftm)$coef
summary(ftm)$coef[1, "t value"]
# manually
SE_beta_0_hat <- summary(ftm)$sigma * sqrt((1/n)
+ (mean(ft$waiting)^2 / Sxx))
SE_beta_0_hat
ftm$coef
ftm$coef[1]
t_val <- ftm$coef[1] / SE_beta_0_hat
t_val
summary(ftm)$coef[1, "t value"]
summary(ftm)$coef[2, "t value"]
# The SE[beta_1_hat] is s_e (estimated sigma, divided by Sxx)
SE_beta_0_hat <- summary(ftm)$sigma / sqrt(Sxx)
# The SE[beta_1_hat] is s_e (estimated sigma, divided by Sxx)
SE_beta_1_hat <- summary(ftm)$sigma / sqrt(Sxx)
# manually
SE_beta_0_hat <- summary(ftm)$sigma * sqrt((1/n)
+ (mean(ft$waiting)^2 / Sxx))
ftm$coefficients
summary(ftm)$coef[2, "t value"]
ftm$coefficients[2] / SE_beta_1_hat
summary(ftm)$coef
summary(ftm)$coef[2, 4]
p_val <- summary(ftm)$coef[2, 4]
p_val < 0.01
p_val <- summary(ftm)$coef[2, 4]
p_val
summary(ftm)$coef[2, "t value"]
# get the p value from the t value
2 * pt(34.08904, df = n - 2, lower.tail = FALSE)
p_val <- summary(ftm)$coef[2, 4]
p_val
# get the p value from the t value
2 * pt(summary(ftm)$coef[2, "t value"],
df = n - 2, lower.tail = FALSE)
p_val
confint(ftm, level = 0.9)
confint(ftm, level = 0.9, parm = "waiting")
confint(ftm, level = 0.9, parm = "ft$waiting")
confint(ftm, level = 0.9, parm = "ft$waiting")[1, 2]
confint(ftm, level = 0.9, parm = "(Intercept)")[1, 2]
confint(ftm, level = 0.95)
confint(ftm, level = 0.95)[2]
confint(ftm, level = 0.95, parm = "ft$waiting")
cint <- confint(ftm, level = 0.95, parm = "ft$waiting")
cint[2] - cint[1]
ftm$coefficients
source('~/.active-rstudio-document', echo=TRUE)
ftm$coefficients[2]
cint[2] - ftm$coefficients[2]
crit <- qt(0.025, df = n - 2)
crit
crit <- abs(qt(0.025, df = n - 2))
crit + SE_beta_1_hat
crit + SE_beta_1_hat
cint[2] - ftm$coefficients[2]
crit <- abs(qt(0.025, df = n - 2))
crit + SE_beta_1_hat
crit <- qt(0.025, df = n - 2)
crit + SE_beta_1_hat
crit <- abs(qt(0.025, df = n - 2))
crit + SE_beta_1_hat
summary(ftm)$coef
# The SE[beta_1_hat] is s_e (estimated sigma, divided by Sxx)
SE_beta_1_hat <- summary(ftm)$sigma / sqrt(Sxx)
SE_beta_1_hat
crit <- abs(qt(0.0025, df = n - 2))
crit + SE_beta_1_hat
crit <- qt(0.0025, df = n - 2, lower.tail = FALSE)
crit + SE_beta_1_hat
cint[2] - ftm$coefficients[2]
crit
crit <- qt(0.0025, df = n - 2, lower.tail = FALSE)
crit * SE_beta_1_hat
cint[2] - ftm$coefficients[2]
crit <- qt(0.025, df = n - 2, lower.tail = FALSE)
crit * SE_beta_1_hat
crit <- qt(0.025, df = n - 2)
crit * SE_beta_1_hat
crit <- abs(qt(0.025, df = n - 2))
crit * SE_beta_1_hat
cint[2] - ftm$coefficients[2]
predict(ftm, level = 0.9, newdata = data.frame(
ft$waiting = 81
))
predict(ftm, level = 0.9, newdata = data.frame(
"ft$waiting" = 81
))
predict(ftm, level = 0.9, newdata = data.frame(
waiting = 81
))
predict(ftm, level = 0.9, newdata = data.frame(
waiting = c(81)
), interval = "confidence")
predict(ftm, level = 0.9, newdata = data.frame(
"ft$waiting" = c(81)
), interval = "confidence")
predict(ftm, level = 0.9, newdata = data.frame(
ft$waiting = c(81)
), interval = "confidence")
predict(ftm, level = 0.9, newdata = data.frame(
waiting = c(81)
), interval = "confidence")
ftm <- lm(eruptions ~ waiting, data = ft)
predict(ftm, level = 0.9, newdata = data.frame(
waiting = c(81)
), interval = "confidence")
predict(ftm, level = 0.9, newdata = data.frame(
waiting = c(81)
), interval = "confidence")["lwr"]
predict(ftm, level = 0.9, newdata = data.frame(
waiting = c(81)
), interval = "confidence")[1, "lwr"]
predict(ftm, level = 0.99, newdata = data.frame(
waiting = c(72)
), interval = "prediction")[1, "upr"]
2 * pf(2.4, df1 = 10 - 9, df2 = 30 - 10, lower.tail = FALSE)
2 * pf(-abs(2.4), df1 = 10 - 9, df2 = 30 - 10)
2 * pf(-abs(2.4), df1 = 10 - 9, df2 = 30 - 10)
pf(-abs(2.4), df1 = 10 - 9, df2 = 30 - 10)
pf(-2.4, df1 = 10 - 9, df2 = 30 - 10)
2 * pf(2.4, df1 = 10 - 9, df2 = 30 - 10, lower.tail = FALSE)
2 * (1 - pf(2.4, df1 = 10 - 9, df2 = 30 - 10))
pf(2.4, df1 = 10 - 9, df2 = 30 - 10, lower.tail = FALSE)
pf(2.4, df1 = 10 - 9, df2 = 30 - 10)
pf(2.4, df1 = 10 - 1, df2 = 30 - 10)
pf(2.4, df1 = 10 - 1, df2 = 30 - 10, lower.tail = FALSE)
# Or we substract from 1
1 - pf(2.4, df1 = 10 - 9, df2 = 30 - 10)
1 - pf(abs(-1.3), df1 = 6 - 5, df2 = 20 - 6)
1 - pf(-1.3, df1 = 6 - 5, df2 = 20 - 6)
2 * pf(-1.3, df1 = 6 - 5, df2 = 20 - 6)
2 * pt(-1.3, df1 = 6 - 5, df2 = 20 - 6)
2 * pt(-1.3, df = 20 - 5)
2 * pt(-1.3, df = 20 - 6)
# Each beta_hat has its own p and t values. Which are related to
# the corresponding null hypothesis
2 * pt(-1.3, df = 20 - 6)
set.seed(42)
x_values = data.frame(
x1 = runif(15),
x2 = runif(15),
x3 = runif(15)
)
ft <- faithful
ftm <- lm(ft$eruptions ~ ft$waiting)
ftm <- lm(eruptions ~ waiting, data = ft)
# RSS or SSE is the numerator for Residual standard error
sse <- sum((ft$eruptions - ftm$fitted.values) ^ 2)
summary(ftm)$sigma
s_e <- sqrt(sse / (nrow(ft) - 2))
s_e
X <- cbind(1, x_values)
X
beta <- c(3, 2, 0.5, 5)
y <- X %*% t(beta)
beta <- cbind(3, 2, 0.5, 5)
beta
beta <- rbind(3, 2, 0.5, 5)
beta
y <- X %*% t(beta)
beta <- matrix(3, 2, 0.5, 5)
beta
beta <- matrix(c(3, 2, 0.5, 5))
beta
y <- X %*% t(beta)
X <- cbind(1, x_values)
beta <- matrix(c(3, 2, 0.5, 5))
y <- X %*% t(beta)
X
y <- 1 %*% t(beta)
y
X <- matrix(1, x_values)
X <- matrix(1, as.matrix(x_values))
X <- matrix(x_values)
X
X <- cbind(1, x_values$x1, x_values$x2, x_values$x3)
X
beta <- matrix(c(3, 2, 0.5, 5))
y <- X %*% t(beta)
beta
y <- X %*% beta
X <- cbind(1, x_values$x1, x_values$x2, x_values$x3)
beta <- matrix(c(3, 2, 0.5, 5))
y <- X %*% beta
C <- solve(t(X) %*% X)
C
9 * C[3, 3]
sqrt(9 * C[3, 3])
# SD is the
9 * C[3, 3]
# SD is the
sqrt(9 * C[3, 3])
?swiss
head(swiss)
smod <- lm(Fertility ~ ., data formula = swiss)
sm <- lm(Fertility ~ ., data formula = swiss)
sm <- lm(Fertility ~ ., data = swiss)
new_pro <- data.frame(
Agriculture 54,
Examination = 23,
Education = 13,
Catholic = 60,
Infant.Mortality = 24
)
new_pro <- data.frame(
Agriculture = 54,
Examination = 23,
Education = 13,
Catholic = 60,
Infant.Mortality = 24
)
predict(sm, newdata = new_pro)
confint(sm, level = 0.99, parm = "Catholic")
confint(sm, level = 0.99, parm = "Catholic")[1, 2]
summary(sm)$coef
summary(sm)$coef["Examination", "Pr(>|t|)"]
head(swiss)
swiss[, 2:]
head(swiss[, 2:6])
matrix(swiss[, 2:6])
as.matrix.data.frame(swiss[, 2:6])
as.matrix(swiss[, 2:6])
as.matrix(swiss[, 2:6])
X <- as.matrix(swiss[, 2:6])
x <- cbind(1, X)
X <- cbind(1, X)
X <- as.matrix(swiss[, 2:6])
X <- cbind(1, X)
X
C <- solve(t(X) %*% X)
C
unname(C)
X <- as.matrix(swiss[, 2:6])
X <- unname(cbind(1, X))
C <- solve(t(X) %*% X)
C
summary(sm)$coef
summary(sm)$sigma
SE_beta_2 <- summary(sm)$sigma * C[3, 3]
SE_beta_2
SE_beta_2 <- summary(sm)$sigma * sqrt(C[3, 3])
sm$coef
sm$coef[1, 3]
sm$coef[3]
t_val <- sm$coef[3] / SE_beta_2
t_val
2 * pt(-abs(t_val), df = nrow(swiss) - 6)
summary(sm)$coef["Examination", "Pr(>|t|)"]
new_pro <- data.frame(
Agriculture = 40,
Examination = 28,
Education = 10,
Catholic = 42,
Infant.Mortality = 27
)
predict(sm, newdata = new_pro, level = 0.95, interval = "confidence")
predict(sm, newdata = new_pro, level = 0.95,
interval = "confidence")[upr]
predict(sm, newdata = new_pro, level = 0.95,
interval = "confidence")["upr"]
predict(sm, newdata = new_pro, level = 0.95,
interval = "confidence")[1, "upr"]
predict(sm, newdata = new_pro, level = 0.95,
interval = "confidence")[1, "lwr"]
predict(sm, newdata = new_pro, level = 0.95,
interval = "prediction")[1, "lwr"]
summary(sm)$f.statistic
summary(sm)$f.statistics
summary(sm)
names(summary(sm))
summary(sm)$fstatistics
summary(sm)$fstatistic
summary(sm)$fstatistic[1]
summary(sm)$coef
summary(sm)
anova(lm(Fertility ~ 1, data = swiss), sm)
anova(lm(Fertility ~ 1, data = swiss), sm)[2, "Pr(>F)"]
pval <- anova(lm(Fertility ~ 1, data = swiss), sm)[2, "Pr(>F)"]
pval < 0.01
summary(sm)$fstatistic[1]
1 - pf(summary(sm)$fstatistic[1], df1 = 6 - 1,
df2 = nrow(swiss))
1 - pf(-summary(sm)$fstatistic[1], df1 = 6 - 1,
df2 = nrow(swiss))
1 - pf(summary(sm)$fstatistic[1], df1 = 6 - 1,
df2 = nrow(swiss))
1 - pf(summary(sm)$fstatistic[1], df1 = 6 - 1,
df2 = nrow(swiss) - 6)
head(swiss)
sm_3 <- lm(Fertility ~ Education + Catholic + Infant.Mortality
, data = swiss)
anova(sm_3, sm)
?anova
anova(sm_3, sm)[2, "Pr(>F)"]
